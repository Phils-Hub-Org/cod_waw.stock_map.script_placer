""" NOTE
(1):
    When testing, you will need to replace the below 'wawRootDir' with your actual WAW root directory
    as well as the 'modName' with the actual name of your mod.

(2):
    The default stock mod launcher behaviour is to copy modName.iwd to appdata/mods folder if it is not present there during the mod.ff stage.
    So this module does take care of that, but for the actual building of the .iwd, check out the 'build_iwd.py' module.

(3):
    During the copy mod.csv from mod folder to zone_source folder stage, if said mod.csv file does not exist, it will be created.

(4):
    When using this in a GUI application, you will need to grab the text from your mod.csv widget section and paste it into the mod.csv file before copying it from mods > zone_source.
    I've added the logic to copy content from mod.csv in mod folder to zone_source folder. So all you need to do for a GUI-based application is copy text from mod.csv widget-section to mod.csv file in mod folder then this module can take care of the rest.    

For output information refer to: 'Misc/building-mod.ff-output.txt'    
"""

import os, sys, csv, shutil, subprocess

def build(modDir: str, zoneSourceDir: str, modName: str, binDir: str, zoneEnglishDir: str, activisionModDir: str, printFunc=print, processFunc=None, addSpaceBetweenSteps=False) -> None:
    # function calls
    steps = [
        lambda arg1=modDir, arg2=zoneSourceDir, arg3=printFunc: copyModCsvFromModToZoneSource(arg1, arg2, arg3),
        lambda arg1=modName, arg2=binDir, arg3=printFunc, arg4=processFunc: buildModFf(arg1, arg2, arg3, arg4),
        lambda arg1=zoneEnglishDir, arg2=modDir, arg3=printFunc: moveModFfFromZoneEnglishToMod(arg1, arg2, arg3),
        lambda arg1=activisionModDir, arg2=modDir, arg3=printFunc: copyModFfFromModToActivisionMod(arg1, arg2, arg3),
        lambda arg1=activisionModDir, arg2=modDir, arg3=modName, arg4=printFunc: copyIwdFromModToActivisionMod(arg1, arg2, arg3, arg4),
    ]

    for step in steps:
        try:
            step()
            if addSpaceBetweenSteps:
                # printFunc('\n')  # for some reason its like this adds 2 newlines
                printFunc('\n'.strip())  # so ensure we only add 1
                
        except Exception as error:
            teardown(f"Step {step.__name__} failed: {error}", printFunc=printFunc)

def copyModCsvFromModToZoneSource(modDir: str, zoneSourceDir: str, printFunc=print) -> None:
    mod_csv_path = os.path.join(modDir, 'mod.csv')

    # Check if the file exists (this would usually be handled by the mod launcher)
    if not os.path.exists(mod_csv_path):
        with open(mod_csv_path, 'w', newline='') as f:
            writer = csv.writer(f)
            # Write your message in a separate row or as a valid CSV row
            writer.writerow(['// auto-generated by build_mod_ff.py'])  # Comment-like message
    
    zone_source_path = os.path.join(zoneSourceDir, 'mod.csv')
    
    shutil.copy2(mod_csv_path, zone_source_path)

    printFunc(f"Copying  {mod_csv_path}")
    printFunc(f"     to  {zone_source_path}")

def buildModFf(modName: str, binDir: str, printFunc=print, processFunc=None) -> None:
    args = ['linker_pc', '-nopause', '-language', 'english', '-moddir', modName, 'mod']

    # Use Popen to run the linker asynchronously
    process = subprocess.Popen(
        args,
        cwd=binDir,
        shell=True,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True  # Enable text mode for easier string handling
    )

    # pass the process object to dev via processFunc
    if processFunc:
        processFunc(process)

    # Read stdout and stderr in real time
    while True:
        output = process.stdout.readline()
        if output == '' and process.poll() is not None:
            break
        if output:
            printFunc(output.strip())

    # Capture the stderr output after the process finishes
    stderr = process.stderr.read()
    if stderr:
        printFunc(stderr.strip())

def moveModFfFromZoneEnglishToMod(zoneEnglishDir: str, modDir: str, printFunc=print) -> None:
    modFfSource = os.path.join(zoneEnglishDir, 'mod.ff')
    modFfDest = os.path.join(modDir, 'mod.ff')

    shutil.move(modFfSource, modFfDest)

    printFunc(f"Moving  {modFfSource}")
    printFunc(f"    to  {modFfDest}")

def copyModFfFromModToActivisionMod(activisionModDir: str, modDir: str, printFunc=print) -> None:
    if not os.path.exists(activisionModDir):
        os.makedirs(activisionModDir)

    modFfSource = os.path.join(modDir, 'mod.ff')
    modFfDest = os.path.join(activisionModDir, 'mod.ff')

    shutil.copy2(modFfSource, modFfDest)

    printFunc(f"Copying  {modFfSource}")
    printFunc(f"     to  {modFfDest}")

def copyIwdFromModToActivisionMod(activisionModDir: str, modDir: str, modName: str, printFunc=print) -> None:
    # Just a nice touch that the stock launcher has where it ensures the modName.iwd is present in appdata/mods folder during the mod.ff stage.
    
    if not os.path.exists(activisionModDir):
        os.makedirs(activisionModDir)

    modIwdSource = os.path.join(modDir, f'{modName}.iwd')
    modIwdDest = os.path.join(activisionModDir, f'{modName}.iwd')
    
    # step 1: check if present in root/mods
    if os.path.exists(modIwdSource):
        # print('iwd present in root/mods')

        # step 2: check if not present in appdata/mods
        if not os.path.exists(modIwdDest):
            # print('iwd not in appdata/mods')

            shutil.copy2(modIwdSource, modIwdDest)

    printFunc(f"Copying  {modIwdSource}")
    printFunc(f"     to  {modIwdDest}")

def teardown(message: str, printFunc=print) -> None:
    printFunc(message)
    sys.exit(1)

# Example usage
if __name__ == '__main__':
    # change these 2 as needed
    # NOTE: Be careful with variables that are in global scope like the below 2.
    #       I change their styling from the args styling so function couldn't utilize them as they should be passed in as args.
    mod_name = 'zm_test1'
    waw_root_dir = r'D:\SteamLibrary\steamapps\common\Call of Duty World at War' 

    print()  # to separate from vs output
    build(
        modDir=os.path.join(os.path.join(waw_root_dir, 'mods'), mod_name),
        zoneSourceDir=os.path.join(waw_root_dir, 'zone_source'),
        modName=mod_name,
        binDir=os.path.join(waw_root_dir, 'bin'),
        zoneEnglishDir=os.path.join(waw_root_dir, 'zone', 'english'),
        activisionModDir=os.path.join(os.path.expanduser('~'), 'AppData', 'Local', 'Activision', 'CoDWaW', 'mods', mod_name),  # '~' = home dir
        # printFunc=print  # the build func already utilizes print as the default output, so only use this arg when wanting to handle the output differently.
        addSpaceBetweenSteps=True
    )
    print()  # to separate from vs output
